// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/fredi12345/kuefa-karben/src/ent/comment"
	"github.com/fredi12345/kuefa-karben/src/ent/event"
	"github.com/fredi12345/kuefa-karben/src/ent/image"
	"github.com/fredi12345/kuefa-karben/src/ent/participant"
	"github.com/fredi12345/kuefa-karben/src/ent/predicate"
	"github.com/fredi12345/kuefa-karben/src/ent/user"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeComment     = "Comment"
	TypeEvent       = "Event"
	TypeImage       = "Image"
	TypeParticipant = "Participant"
	TypeUser        = "User"
)

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created       *time.Time
	name          *string
	message       *string
	menu          *comment.Menu
	clearedFields map[string]struct{}
	event         *uuid.UUID
	clearedevent  bool
	done          bool
	oldValue      func(context.Context) (*Comment, error)
	predicates    []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id uuid.UUID) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreated sets the "created" field.
func (m *CommentMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *CommentMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *CommentMutation) ResetCreated() {
	m.created = nil
}

// SetName sets the "name" field.
func (m *CommentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CommentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CommentMutation) ResetName() {
	m.name = nil
}

// SetMessage sets the "message" field.
func (m *CommentMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *CommentMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *CommentMutation) ResetMessage() {
	m.message = nil
}

// SetMenu sets the "menu" field.
func (m *CommentMutation) SetMenu(c comment.Menu) {
	m.menu = &c
}

// Menu returns the value of the "menu" field in the mutation.
func (m *CommentMutation) Menu() (r comment.Menu, exists bool) {
	v := m.menu
	if v == nil {
		return
	}
	return *v, true
}

// OldMenu returns the old "menu" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldMenu(ctx context.Context) (v comment.Menu, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenu: %w", err)
	}
	return oldValue.Menu, nil
}

// ResetMenu resets all changes to the "menu" field.
func (m *CommentMutation) ResetMenu() {
	m.menu = nil
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *CommentMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *CommentMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *CommentMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *CommentMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *CommentMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created != nil {
		fields = append(fields, comment.FieldCreated)
	}
	if m.name != nil {
		fields = append(fields, comment.FieldName)
	}
	if m.message != nil {
		fields = append(fields, comment.FieldMessage)
	}
	if m.menu != nil {
		fields = append(fields, comment.FieldMenu)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreated:
		return m.Created()
	case comment.FieldName:
		return m.Name()
	case comment.FieldMessage:
		return m.Message()
	case comment.FieldMenu:
		return m.Menu()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldCreated:
		return m.OldCreated(ctx)
	case comment.FieldName:
		return m.OldName(ctx)
	case comment.FieldMessage:
		return m.OldMessage(ctx)
	case comment.FieldMenu:
		return m.OldMenu(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case comment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case comment.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case comment.FieldMenu:
		v, ok := value.(comment.Menu)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenu(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldCreated:
		m.ResetCreated()
		return nil
	case comment.FieldName:
		m.ResetName()
		return nil
	case comment.FieldMessage:
		m.ResetMessage()
		return nil
	case comment.FieldMenu:
		m.ResetMenu()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.event != nil {
		edges = append(edges, comment.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevent {
		edges = append(edges, comment.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created             *time.Time
	last_modified       *time.Time
	theme               *string
	title_image         *string
	starting_time       *time.Time
	closing_time        *time.Time
	starter             *string
	main_dish           *string
	dessert             *string
	description         *string
	clearedFields       map[string]struct{}
	participants        map[uuid.UUID]struct{}
	removedparticipants map[uuid.UUID]struct{}
	clearedparticipants bool
	comments            map[uuid.UUID]struct{}
	removedcomments     map[uuid.UUID]struct{}
	clearedcomments     bool
	images              map[uuid.UUID]struct{}
	removedimages       map[uuid.UUID]struct{}
	clearedimages       bool
	done                bool
	oldValue            func(context.Context) (*Event, error)
	predicates          []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id uuid.UUID) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreated sets the "created" field.
func (m *EventMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *EventMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *EventMutation) ResetCreated() {
	m.created = nil
}

// SetLastModified sets the "last_modified" field.
func (m *EventMutation) SetLastModified(t time.Time) {
	m.last_modified = &t
}

// LastModified returns the value of the "last_modified" field in the mutation.
func (m *EventMutation) LastModified() (r time.Time, exists bool) {
	v := m.last_modified
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModified returns the old "last_modified" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLastModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModified: %w", err)
	}
	return oldValue.LastModified, nil
}

// ResetLastModified resets all changes to the "last_modified" field.
func (m *EventMutation) ResetLastModified() {
	m.last_modified = nil
}

// SetTheme sets the "theme" field.
func (m *EventMutation) SetTheme(s string) {
	m.theme = &s
}

// Theme returns the value of the "theme" field in the mutation.
func (m *EventMutation) Theme() (r string, exists bool) {
	v := m.theme
	if v == nil {
		return
	}
	return *v, true
}

// OldTheme returns the old "theme" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTheme(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTheme: %w", err)
	}
	return oldValue.Theme, nil
}

// ResetTheme resets all changes to the "theme" field.
func (m *EventMutation) ResetTheme() {
	m.theme = nil
}

// SetTitleImage sets the "title_image" field.
func (m *EventMutation) SetTitleImage(s string) {
	m.title_image = &s
}

// TitleImage returns the value of the "title_image" field in the mutation.
func (m *EventMutation) TitleImage() (r string, exists bool) {
	v := m.title_image
	if v == nil {
		return
	}
	return *v, true
}

// OldTitleImage returns the old "title_image" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTitleImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitleImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitleImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitleImage: %w", err)
	}
	return oldValue.TitleImage, nil
}

// ResetTitleImage resets all changes to the "title_image" field.
func (m *EventMutation) ResetTitleImage() {
	m.title_image = nil
}

// SetStartingTime sets the "starting_time" field.
func (m *EventMutation) SetStartingTime(t time.Time) {
	m.starting_time = &t
}

// StartingTime returns the value of the "starting_time" field in the mutation.
func (m *EventMutation) StartingTime() (r time.Time, exists bool) {
	v := m.starting_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartingTime returns the old "starting_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldStartingTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartingTime: %w", err)
	}
	return oldValue.StartingTime, nil
}

// ResetStartingTime resets all changes to the "starting_time" field.
func (m *EventMutation) ResetStartingTime() {
	m.starting_time = nil
}

// SetClosingTime sets the "closing_time" field.
func (m *EventMutation) SetClosingTime(t time.Time) {
	m.closing_time = &t
}

// ClosingTime returns the value of the "closing_time" field in the mutation.
func (m *EventMutation) ClosingTime() (r time.Time, exists bool) {
	v := m.closing_time
	if v == nil {
		return
	}
	return *v, true
}

// OldClosingTime returns the old "closing_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldClosingTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosingTime: %w", err)
	}
	return oldValue.ClosingTime, nil
}

// ClearClosingTime clears the value of the "closing_time" field.
func (m *EventMutation) ClearClosingTime() {
	m.closing_time = nil
	m.clearedFields[event.FieldClosingTime] = struct{}{}
}

// ClosingTimeCleared returns if the "closing_time" field was cleared in this mutation.
func (m *EventMutation) ClosingTimeCleared() bool {
	_, ok := m.clearedFields[event.FieldClosingTime]
	return ok
}

// ResetClosingTime resets all changes to the "closing_time" field.
func (m *EventMutation) ResetClosingTime() {
	m.closing_time = nil
	delete(m.clearedFields, event.FieldClosingTime)
}

// SetStarter sets the "starter" field.
func (m *EventMutation) SetStarter(s string) {
	m.starter = &s
}

// Starter returns the value of the "starter" field in the mutation.
func (m *EventMutation) Starter() (r string, exists bool) {
	v := m.starter
	if v == nil {
		return
	}
	return *v, true
}

// OldStarter returns the old "starter" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldStarter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStarter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStarter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStarter: %w", err)
	}
	return oldValue.Starter, nil
}

// ResetStarter resets all changes to the "starter" field.
func (m *EventMutation) ResetStarter() {
	m.starter = nil
}

// SetMainDish sets the "main_dish" field.
func (m *EventMutation) SetMainDish(s string) {
	m.main_dish = &s
}

// MainDish returns the value of the "main_dish" field in the mutation.
func (m *EventMutation) MainDish() (r string, exists bool) {
	v := m.main_dish
	if v == nil {
		return
	}
	return *v, true
}

// OldMainDish returns the old "main_dish" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMainDish(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMainDish is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMainDish requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainDish: %w", err)
	}
	return oldValue.MainDish, nil
}

// ResetMainDish resets all changes to the "main_dish" field.
func (m *EventMutation) ResetMainDish() {
	m.main_dish = nil
}

// SetDessert sets the "dessert" field.
func (m *EventMutation) SetDessert(s string) {
	m.dessert = &s
}

// Dessert returns the value of the "dessert" field in the mutation.
func (m *EventMutation) Dessert() (r string, exists bool) {
	v := m.dessert
	if v == nil {
		return
	}
	return *v, true
}

// OldDessert returns the old "dessert" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDessert(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDessert is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDessert requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDessert: %w", err)
	}
	return oldValue.Dessert, nil
}

// ResetDessert resets all changes to the "dessert" field.
func (m *EventMutation) ResetDessert() {
	m.dessert = nil
}

// SetDescription sets the "description" field.
func (m *EventMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EventMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *EventMutation) ResetDescription() {
	m.description = nil
}

// AddParticipantIDs adds the "participants" edge to the Participant entity by ids.
func (m *EventMutation) AddParticipantIDs(ids ...uuid.UUID) {
	if m.participants == nil {
		m.participants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.participants[ids[i]] = struct{}{}
	}
}

// ClearParticipants clears the "participants" edge to the Participant entity.
func (m *EventMutation) ClearParticipants() {
	m.clearedparticipants = true
}

// ParticipantsCleared reports if the "participants" edge to the Participant entity was cleared.
func (m *EventMutation) ParticipantsCleared() bool {
	return m.clearedparticipants
}

// RemoveParticipantIDs removes the "participants" edge to the Participant entity by IDs.
func (m *EventMutation) RemoveParticipantIDs(ids ...uuid.UUID) {
	if m.removedparticipants == nil {
		m.removedparticipants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.participants, ids[i])
		m.removedparticipants[ids[i]] = struct{}{}
	}
}

// RemovedParticipants returns the removed IDs of the "participants" edge to the Participant entity.
func (m *EventMutation) RemovedParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.removedparticipants {
		ids = append(ids, id)
	}
	return
}

// ParticipantsIDs returns the "participants" edge IDs in the mutation.
func (m *EventMutation) ParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.participants {
		ids = append(ids, id)
	}
	return
}

// ResetParticipants resets all changes to the "participants" edge.
func (m *EventMutation) ResetParticipants() {
	m.participants = nil
	m.clearedparticipants = false
	m.removedparticipants = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *EventMutation) AddCommentIDs(ids ...uuid.UUID) {
	if m.comments == nil {
		m.comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *EventMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *EventMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *EventMutation) RemoveCommentIDs(ids ...uuid.UUID) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *EventMutation) RemovedCommentsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *EventMutation) CommentsIDs() (ids []uuid.UUID) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *EventMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddImageIDs adds the "images" edge to the Image entity by ids.
func (m *EventMutation) AddImageIDs(ids ...uuid.UUID) {
	if m.images == nil {
		m.images = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Image entity.
func (m *EventMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Image entity was cleared.
func (m *EventMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Image entity by IDs.
func (m *EventMutation) RemoveImageIDs(ids ...uuid.UUID) {
	if m.removedimages == nil {
		m.removedimages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Image entity.
func (m *EventMutation) RemovedImagesIDs() (ids []uuid.UUID) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *EventMutation) ImagesIDs() (ids []uuid.UUID) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *EventMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created != nil {
		fields = append(fields, event.FieldCreated)
	}
	if m.last_modified != nil {
		fields = append(fields, event.FieldLastModified)
	}
	if m.theme != nil {
		fields = append(fields, event.FieldTheme)
	}
	if m.title_image != nil {
		fields = append(fields, event.FieldTitleImage)
	}
	if m.starting_time != nil {
		fields = append(fields, event.FieldStartingTime)
	}
	if m.closing_time != nil {
		fields = append(fields, event.FieldClosingTime)
	}
	if m.starter != nil {
		fields = append(fields, event.FieldStarter)
	}
	if m.main_dish != nil {
		fields = append(fields, event.FieldMainDish)
	}
	if m.dessert != nil {
		fields = append(fields, event.FieldDessert)
	}
	if m.description != nil {
		fields = append(fields, event.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreated:
		return m.Created()
	case event.FieldLastModified:
		return m.LastModified()
	case event.FieldTheme:
		return m.Theme()
	case event.FieldTitleImage:
		return m.TitleImage()
	case event.FieldStartingTime:
		return m.StartingTime()
	case event.FieldClosingTime:
		return m.ClosingTime()
	case event.FieldStarter:
		return m.Starter()
	case event.FieldMainDish:
		return m.MainDish()
	case event.FieldDessert:
		return m.Dessert()
	case event.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldCreated:
		return m.OldCreated(ctx)
	case event.FieldLastModified:
		return m.OldLastModified(ctx)
	case event.FieldTheme:
		return m.OldTheme(ctx)
	case event.FieldTitleImage:
		return m.OldTitleImage(ctx)
	case event.FieldStartingTime:
		return m.OldStartingTime(ctx)
	case event.FieldClosingTime:
		return m.OldClosingTime(ctx)
	case event.FieldStarter:
		return m.OldStarter(ctx)
	case event.FieldMainDish:
		return m.OldMainDish(ctx)
	case event.FieldDessert:
		return m.OldDessert(ctx)
	case event.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case event.FieldLastModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModified(v)
		return nil
	case event.FieldTheme:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTheme(v)
		return nil
	case event.FieldTitleImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitleImage(v)
		return nil
	case event.FieldStartingTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartingTime(v)
		return nil
	case event.FieldClosingTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosingTime(v)
		return nil
	case event.FieldStarter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStarter(v)
		return nil
	case event.FieldMainDish:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainDish(v)
		return nil
	case event.FieldDessert:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDessert(v)
		return nil
	case event.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldClosingTime) {
		fields = append(fields, event.FieldClosingTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldClosingTime:
		m.ClearClosingTime()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldCreated:
		m.ResetCreated()
		return nil
	case event.FieldLastModified:
		m.ResetLastModified()
		return nil
	case event.FieldTheme:
		m.ResetTheme()
		return nil
	case event.FieldTitleImage:
		m.ResetTitleImage()
		return nil
	case event.FieldStartingTime:
		m.ResetStartingTime()
		return nil
	case event.FieldClosingTime:
		m.ResetClosingTime()
		return nil
	case event.FieldStarter:
		m.ResetStarter()
		return nil
	case event.FieldMainDish:
		m.ResetMainDish()
		return nil
	case event.FieldDessert:
		m.ResetDessert()
		return nil
	case event.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.participants != nil {
		edges = append(edges, event.EdgeParticipants)
	}
	if m.comments != nil {
		edges = append(edges, event.EdgeComments)
	}
	if m.images != nil {
		edges = append(edges, event.EdgeImages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.participants))
		for id := range m.participants {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedparticipants != nil {
		edges = append(edges, event.EdgeParticipants)
	}
	if m.removedcomments != nil {
		edges = append(edges, event.EdgeComments)
	}
	if m.removedimages != nil {
		edges = append(edges, event.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.removedparticipants))
		for id := range m.removedparticipants {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparticipants {
		edges = append(edges, event.EdgeParticipants)
	}
	if m.clearedcomments {
		edges = append(edges, event.EdgeComments)
	}
	if m.clearedimages {
		edges = append(edges, event.EdgeImages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeParticipants:
		return m.clearedparticipants
	case event.EdgeComments:
		return m.clearedcomments
	case event.EdgeImages:
		return m.clearedimages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeParticipants:
		m.ResetParticipants()
		return nil
	case event.EdgeComments:
		m.ResetComments()
		return nil
	case event.EdgeImages:
		m.ResetImages()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// ImageMutation represents an operation that mutates the Image nodes in the graph.
type ImageMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created       *time.Time
	file_name     *string
	clearedFields map[string]struct{}
	event         *uuid.UUID
	clearedevent  bool
	done          bool
	oldValue      func(context.Context) (*Image, error)
	predicates    []predicate.Image
}

var _ ent.Mutation = (*ImageMutation)(nil)

// imageOption allows management of the mutation configuration using functional options.
type imageOption func(*ImageMutation)

// newImageMutation creates new mutation for the Image entity.
func newImageMutation(c config, op Op, opts ...imageOption) *ImageMutation {
	m := &ImageMutation{
		config:        c,
		op:            op,
		typ:           TypeImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageID sets the ID field of the mutation.
func withImageID(id uuid.UUID) imageOption {
	return func(m *ImageMutation) {
		var (
			err   error
			once  sync.Once
			value *Image
		)
		m.oldValue = func(ctx context.Context) (*Image, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Image.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImage sets the old Image of the mutation.
func withImage(node *Image) imageOption {
	return func(m *ImageMutation) {
		m.oldValue = func(context.Context) (*Image, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Image entities.
func (m *ImageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Image.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreated sets the "created" field.
func (m *ImageMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *ImageMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *ImageMutation) ResetCreated() {
	m.created = nil
}

// SetFileName sets the "file_name" field.
func (m *ImageMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *ImageMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *ImageMutation) ResetFileName() {
	m.file_name = nil
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *ImageMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *ImageMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *ImageMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *ImageMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *ImageMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the ImageMutation builder.
func (m *ImageMutation) Where(ps ...predicate.Image) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ImageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Image).
func (m *ImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created != nil {
		fields = append(fields, image.FieldCreated)
	}
	if m.file_name != nil {
		fields = append(fields, image.FieldFileName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case image.FieldCreated:
		return m.Created()
	case image.FieldFileName:
		return m.FileName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case image.FieldCreated:
		return m.OldCreated(ctx)
	case image.FieldFileName:
		return m.OldFileName(ctx)
	}
	return nil, fmt.Errorf("unknown Image field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case image.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case image.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Image numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Image nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageMutation) ResetField(name string) error {
	switch name {
	case image.FieldCreated:
		m.ResetCreated()
		return nil
	case image.FieldFileName:
		m.ResetFileName()
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.event != nil {
		edges = append(edges, image.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevent {
		edges = append(edges, image.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageMutation) EdgeCleared(name string) bool {
	switch name {
	case image.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageMutation) ClearEdge(name string) error {
	switch name {
	case image.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown Image unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageMutation) ResetEdge(name string) error {
	switch name {
	case image.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown Image edge %s", name)
}

// ParticipantMutation represents an operation that mutates the Participant nodes in the graph.
type ParticipantMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created            *time.Time
	name               *string
	message            *string
	classic_menu       *int
	addclassic_menu    *int
	vegetarian_menu    *int
	addvegetarian_menu *int
	vegan_menu         *int
	addvegan_menu      *int
	clearedFields      map[string]struct{}
	event              *uuid.UUID
	clearedevent       bool
	done               bool
	oldValue           func(context.Context) (*Participant, error)
	predicates         []predicate.Participant
}

var _ ent.Mutation = (*ParticipantMutation)(nil)

// participantOption allows management of the mutation configuration using functional options.
type participantOption func(*ParticipantMutation)

// newParticipantMutation creates new mutation for the Participant entity.
func newParticipantMutation(c config, op Op, opts ...participantOption) *ParticipantMutation {
	m := &ParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withParticipantID sets the ID field of the mutation.
func withParticipantID(id uuid.UUID) participantOption {
	return func(m *ParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *Participant
		)
		m.oldValue = func(ctx context.Context) (*Participant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Participant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParticipant sets the old Participant of the mutation.
func withParticipant(node *Participant) participantOption {
	return func(m *ParticipantMutation) {
		m.oldValue = func(context.Context) (*Participant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Participant entities.
func (m *ParticipantMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ParticipantMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ParticipantMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Participant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreated sets the "created" field.
func (m *ParticipantMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *ParticipantMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Participant entity.
// If the Participant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParticipantMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *ParticipantMutation) ResetCreated() {
	m.created = nil
}

// SetName sets the "name" field.
func (m *ParticipantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ParticipantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Participant entity.
// If the Participant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParticipantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ParticipantMutation) ResetName() {
	m.name = nil
}

// SetMessage sets the "message" field.
func (m *ParticipantMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *ParticipantMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Participant entity.
// If the Participant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParticipantMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *ParticipantMutation) ResetMessage() {
	m.message = nil
}

// SetClassicMenu sets the "classic_menu" field.
func (m *ParticipantMutation) SetClassicMenu(i int) {
	m.classic_menu = &i
	m.addclassic_menu = nil
}

// ClassicMenu returns the value of the "classic_menu" field in the mutation.
func (m *ParticipantMutation) ClassicMenu() (r int, exists bool) {
	v := m.classic_menu
	if v == nil {
		return
	}
	return *v, true
}

// OldClassicMenu returns the old "classic_menu" field's value of the Participant entity.
// If the Participant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParticipantMutation) OldClassicMenu(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassicMenu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassicMenu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassicMenu: %w", err)
	}
	return oldValue.ClassicMenu, nil
}

// AddClassicMenu adds i to the "classic_menu" field.
func (m *ParticipantMutation) AddClassicMenu(i int) {
	if m.addclassic_menu != nil {
		*m.addclassic_menu += i
	} else {
		m.addclassic_menu = &i
	}
}

// AddedClassicMenu returns the value that was added to the "classic_menu" field in this mutation.
func (m *ParticipantMutation) AddedClassicMenu() (r int, exists bool) {
	v := m.addclassic_menu
	if v == nil {
		return
	}
	return *v, true
}

// ResetClassicMenu resets all changes to the "classic_menu" field.
func (m *ParticipantMutation) ResetClassicMenu() {
	m.classic_menu = nil
	m.addclassic_menu = nil
}

// SetVegetarianMenu sets the "vegetarian_menu" field.
func (m *ParticipantMutation) SetVegetarianMenu(i int) {
	m.vegetarian_menu = &i
	m.addvegetarian_menu = nil
}

// VegetarianMenu returns the value of the "vegetarian_menu" field in the mutation.
func (m *ParticipantMutation) VegetarianMenu() (r int, exists bool) {
	v := m.vegetarian_menu
	if v == nil {
		return
	}
	return *v, true
}

// OldVegetarianMenu returns the old "vegetarian_menu" field's value of the Participant entity.
// If the Participant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParticipantMutation) OldVegetarianMenu(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVegetarianMenu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVegetarianMenu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVegetarianMenu: %w", err)
	}
	return oldValue.VegetarianMenu, nil
}

// AddVegetarianMenu adds i to the "vegetarian_menu" field.
func (m *ParticipantMutation) AddVegetarianMenu(i int) {
	if m.addvegetarian_menu != nil {
		*m.addvegetarian_menu += i
	} else {
		m.addvegetarian_menu = &i
	}
}

// AddedVegetarianMenu returns the value that was added to the "vegetarian_menu" field in this mutation.
func (m *ParticipantMutation) AddedVegetarianMenu() (r int, exists bool) {
	v := m.addvegetarian_menu
	if v == nil {
		return
	}
	return *v, true
}

// ResetVegetarianMenu resets all changes to the "vegetarian_menu" field.
func (m *ParticipantMutation) ResetVegetarianMenu() {
	m.vegetarian_menu = nil
	m.addvegetarian_menu = nil
}

// SetVeganMenu sets the "vegan_menu" field.
func (m *ParticipantMutation) SetVeganMenu(i int) {
	m.vegan_menu = &i
	m.addvegan_menu = nil
}

// VeganMenu returns the value of the "vegan_menu" field in the mutation.
func (m *ParticipantMutation) VeganMenu() (r int, exists bool) {
	v := m.vegan_menu
	if v == nil {
		return
	}
	return *v, true
}

// OldVeganMenu returns the old "vegan_menu" field's value of the Participant entity.
// If the Participant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParticipantMutation) OldVeganMenu(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVeganMenu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVeganMenu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVeganMenu: %w", err)
	}
	return oldValue.VeganMenu, nil
}

// AddVeganMenu adds i to the "vegan_menu" field.
func (m *ParticipantMutation) AddVeganMenu(i int) {
	if m.addvegan_menu != nil {
		*m.addvegan_menu += i
	} else {
		m.addvegan_menu = &i
	}
}

// AddedVeganMenu returns the value that was added to the "vegan_menu" field in this mutation.
func (m *ParticipantMutation) AddedVeganMenu() (r int, exists bool) {
	v := m.addvegan_menu
	if v == nil {
		return
	}
	return *v, true
}

// ResetVeganMenu resets all changes to the "vegan_menu" field.
func (m *ParticipantMutation) ResetVeganMenu() {
	m.vegan_menu = nil
	m.addvegan_menu = nil
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *ParticipantMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *ParticipantMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *ParticipantMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *ParticipantMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *ParticipantMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *ParticipantMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the ParticipantMutation builder.
func (m *ParticipantMutation) Where(ps ...predicate.Participant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ParticipantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Participant).
func (m *ParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ParticipantMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created != nil {
		fields = append(fields, participant.FieldCreated)
	}
	if m.name != nil {
		fields = append(fields, participant.FieldName)
	}
	if m.message != nil {
		fields = append(fields, participant.FieldMessage)
	}
	if m.classic_menu != nil {
		fields = append(fields, participant.FieldClassicMenu)
	}
	if m.vegetarian_menu != nil {
		fields = append(fields, participant.FieldVegetarianMenu)
	}
	if m.vegan_menu != nil {
		fields = append(fields, participant.FieldVeganMenu)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case participant.FieldCreated:
		return m.Created()
	case participant.FieldName:
		return m.Name()
	case participant.FieldMessage:
		return m.Message()
	case participant.FieldClassicMenu:
		return m.ClassicMenu()
	case participant.FieldVegetarianMenu:
		return m.VegetarianMenu()
	case participant.FieldVeganMenu:
		return m.VeganMenu()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case participant.FieldCreated:
		return m.OldCreated(ctx)
	case participant.FieldName:
		return m.OldName(ctx)
	case participant.FieldMessage:
		return m.OldMessage(ctx)
	case participant.FieldClassicMenu:
		return m.OldClassicMenu(ctx)
	case participant.FieldVegetarianMenu:
		return m.OldVegetarianMenu(ctx)
	case participant.FieldVeganMenu:
		return m.OldVeganMenu(ctx)
	}
	return nil, fmt.Errorf("unknown Participant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case participant.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case participant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case participant.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case participant.FieldClassicMenu:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassicMenu(v)
		return nil
	case participant.FieldVegetarianMenu:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVegetarianMenu(v)
		return nil
	case participant.FieldVeganMenu:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVeganMenu(v)
		return nil
	}
	return fmt.Errorf("unknown Participant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ParticipantMutation) AddedFields() []string {
	var fields []string
	if m.addclassic_menu != nil {
		fields = append(fields, participant.FieldClassicMenu)
	}
	if m.addvegetarian_menu != nil {
		fields = append(fields, participant.FieldVegetarianMenu)
	}
	if m.addvegan_menu != nil {
		fields = append(fields, participant.FieldVeganMenu)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ParticipantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case participant.FieldClassicMenu:
		return m.AddedClassicMenu()
	case participant.FieldVegetarianMenu:
		return m.AddedVegetarianMenu()
	case participant.FieldVeganMenu:
		return m.AddedVeganMenu()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case participant.FieldClassicMenu:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClassicMenu(v)
		return nil
	case participant.FieldVegetarianMenu:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVegetarianMenu(v)
		return nil
	case participant.FieldVeganMenu:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVeganMenu(v)
		return nil
	}
	return fmt.Errorf("unknown Participant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ParticipantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ParticipantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Participant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ParticipantMutation) ResetField(name string) error {
	switch name {
	case participant.FieldCreated:
		m.ResetCreated()
		return nil
	case participant.FieldName:
		m.ResetName()
		return nil
	case participant.FieldMessage:
		m.ResetMessage()
		return nil
	case participant.FieldClassicMenu:
		m.ResetClassicMenu()
		return nil
	case participant.FieldVegetarianMenu:
		m.ResetVegetarianMenu()
		return nil
	case participant.FieldVeganMenu:
		m.ResetVeganMenu()
		return nil
	}
	return fmt.Errorf("unknown Participant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.event != nil {
		edges = append(edges, participant.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case participant.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ParticipantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevent {
		edges = append(edges, participant.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case participant.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ParticipantMutation) ClearEdge(name string) error {
	switch name {
	case participant.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown Participant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ParticipantMutation) ResetEdge(name string) error {
	switch name {
	case participant.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown Participant edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created       *time.Time
	name          *string
	password      *[]byte
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreated sets the "created" field.
func (m *UserMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *UserMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *UserMutation) ResetCreated() {
	m.created = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created != nil {
		fields = append(fields, user.FieldCreated)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreated:
		return m.Created()
	case user.FieldName:
		return m.Name()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreated:
		return m.OldCreated(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreated:
		m.ResetCreated()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
